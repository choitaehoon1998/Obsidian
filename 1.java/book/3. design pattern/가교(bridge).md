#### 의도 
구현에서 추상을 분리하여 이들이 독립적으로 다양성을 가질 수 있도록합니다. 

#### 다른이름 
핸들/구현부 (Handle /Body)


#### 동기 
하나의 추상적 개념이 여러 가지 구현으로 구체화될 수 있을때, 대부분은 상속을 통하여 이 문제를 해결한다, 추상 클래스로 추상적 개념에 대한 인터페이스를 정의하고, 구체적인 서브클래스들에서 서로 다른 방식으로 이들 인터페이스를 정의하고, 구체적인 서브클래스들에서 서로 다른 방식으로 이들 인터페이스를 구현한다. 하지만 이 방법 만으로는 충분한 융통성을 얻을 수 없다. 상속은 구현과 추상적 개념을 영구적으로 종속시키기 때문에, 추상적 개념과 구현을 분리하여 재사용하거나 수정, 확장하기가 쉽지않다. 

이식성 있는 window를 추상적 개념으로 보고 이를 사용자 인터페이스 툴킷을 써서 구현하는 예를 생각해보면 이 Window 추상화는 x 윈도우 시스템에서 운영이 가능한 응용프로그램에서 사용되거나, ibm의 프레젠테이션 매니저에서 운영되는 응용프로그램에 적용될 수 있다. 상속을 이용한다면 window 추상클래스를 저으이하고 이를 상속 받아 서로 다른 플랫폼에서 운영될 pmwinodw, xwinodw클래스를 구현하면된다. 

이 방법에는 2가지 문제가 존재하는데 

1. 윈도우이기는 하지만 다른 개념의 윈도우를 생성하거나 새로운 플랫폼에서 운영 가능한 윈도우를 만들기 위해 winodw 추상을 확장하기가 어렵다. 
	- 예를 들어 새로운 개념의 윈도우로 iconWindow를 window의 서브클래스로 만들었다고 가정하면 이새로운 IconWindow가 만약 x윈도우와 pm 윈도우에서 모두 동작 가능하려면 새로운 클래스인 XIconWindow와 PmIconWindow 서브클래스를 구현해야 한다. 이런식으로 구현하면 앞으로 만들 새로운 종류의 윈도우 마다 서로 다른 플랫폼을 지원하는데 필요한 클래스를 새로 만들어야 한다. 
2. 사용자 코드가 플랫폼에 종속된다 사용자가 윈도우를 만들때마다 특정한 구현을 가진 구체 클래스를 인스턴스화해야 하는데, 이 특정한 구현이 바로 플랫폼에 종속적인 구현이다. 
	- 예를 들어 Xwindow객체를 생성하면 Window추상이 XWindow 구현에 묶이게 된다. 따라서 사용자 코드 역시 XWindow 구현에 종속적으로 만들어진다. 이는 응용프로그램이 서로 다른 플랫폼에 이식하기가 어려움을 의미한다
	- 사용자는 구체적인 구현에 종속적일 필요없이도 윈도우를 생성할 수 있어야 한다. 

이러한 문제를 해결하기 위해 기교 패턴 (bridge)을 사용할수 있다. 윈토우 인터페이스에 대한 계통하나와 구현에 해당하는 계통하나를 따로 구축한다. 