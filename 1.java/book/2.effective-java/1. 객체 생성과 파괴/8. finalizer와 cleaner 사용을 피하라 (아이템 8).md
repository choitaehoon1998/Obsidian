
### 자바의 두 가지 객체 소멸자 
- 두가지 모두 즉시 수행된다는 보장이 없다. 객체에 접근 할수 없게 된후 finalizer나 cleaner가 실행되기까지 얼마나 걸릴지 알수 없다. 즉 finzliaer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할수 없다. 
- 얼마나 신속하게 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달렸으며 이는 가비지 컬렉터 구현마다 천차 만별이다. 
- 수행시점 뿐 아니라 수행여부 조차 보장하지 못한다. 
- 상태를 수정하는 작업에서는 절대 객체 소멸자에 의존해서는 안된다. 
- 심각한 성능 문제도 동반한다. 
#### finalizer 
- 예측할수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 
- 오작동, 낮은 성능, 이식성 문제의 원인이 되기도 한다. 
- 기본적으로 쓰지 말아야 한다. 
- finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. 
#### cleaner
- finalizer 보다는 덜 위험하지만, 여전히 예측할수 없고, 느리고 일반적으로는 불 필요하다. 


### 그렇다면 대안은? 
#### AutoClosable
- 그저 AutoClosable을 구현해주고 클라이언트에서 인스턴스를 다쓰고 나면 close메서드를 호출하면된다. (예외가 발생하더라도 제대로 종료되도록 try-with-resources를 사용해야한다. [[9. try-finally보다는 try-with-resource를 사용하라 (아이템 9)]])


### 그럼 객체 소멸자는 언제 사용하는가? 
1. 자원의 소유자가 close 메서드를 호출 하지 않는 것에 대비한 안정망 역할이다
   - cleaner나 finalizer가 즉시 호출 되리라는 보장은 없지만, 클라이언트가 하지않은 자원 회수를 늦게라도 해주는것이 아예 안 하는것 보다는 낫다. 이런 안정망 역활을 finalizer는 그럴만한 가치가 있는지 심사숙고하자
2. 네이티브 피어와 연결된 객체에서다 
   - 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 네이티브 피어는 자바 객체가 아니닌 가비지 컬렉터는 그존재를 알지 못한다. 그결과 자바 피어를 회수 할 때 네이티브 객체까지 회수하지 못한다. cleaner나 finalzier가 나서서 처리 하기에 적당한 작업이다. 단 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당된다. 성능 저하를 감당 할수 없거나 네이티브 피어가 사용하는 자원을 즉시 회수해야한다면 앞서 설명한 close메서드를 사용해야한다. 